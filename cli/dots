#!/usr/bin/env python3

import os
import re
import yaml
import argparse

from modules import context
from modules import config
from modules.plugins import plugin
from modules.util import env, logger, tools


def _parse_args():
    parser = argparse.ArgumentParser(description='Yet another yet another dotfiles management tool')

    parser.add_argument(
        '--config-file', '-c',
        help='Configuration description (.yaml)',
        default=os.getenv(env.CONFIG_FILE_PATH_ENV_VAR),
    )
    parser.add_argument(
        '--root',
        help='dottols root directory',
        default=os.getenv(
            env.ROOT_PATH_ENV_VAR,
            default=os.path.dirname(os.path.dirname(__file__)),
        ),
    )
    parser.add_argument(
        '--log-level', '-l',
        help='Logging level [None=0..All=5]',
        default=1,
        action='store',
        type=int,
    )
    parser.add_argument(
        '--dry-run',
        help='Only print actions without actually applying them',
        action='store_true',
    )
    parser.add_argument(
        '--field', '-f',
        help='The object to be processed',
        default='.*',
    )
    parser.add_argument(
        '--color',
        help='Whether to display color in output',
        choices=['yes', 'no'],
        default='yes',
    )

    subparsers = parser.add_subparsers(title='Commands', dest='command')
    subparsers.add_parser('diff', help='Show difference')
    subparsers.add_parser('plan', help='Print actions that will be done when apply is used')
    subparsers.add_parser('apply', help='Apply configuration')
    compile_parser = subparsers.add_parser('compile', help='Show preprocessed configuration')
    compile_parser.add_argument(
        '--full',
        help='Print extended config value',
        action='store_true',
    )

    return parser.parse_args()


def _apply_command(args, plugin_instance, command):
    with logger.logger().indent(label=command):
        if command == 'compile':
            if args.full:
                logger.logger().output(
                    [''] + tools.safe_dump_yaml_lines(plugin_instance.config)
                )
            else:
                logger.logger().output(
                    [''] + tools.safe_dump_yaml_lines(plugin_instance.config.to_dict())
                )
            return

        if command == 'diff':
            plugin.Plugin.log_difference(plugin_instance.difference())
            return

        if command == 'apply':
            if not plugin.Plugin.any_difference(plugin_instance.difference()):
                logger.logger().info('No difference, nothing done')
                return

            plugin_instance.backup()
            plugin_instance.apply()
            return

        assert False, f'Invalid command {command}'


def main(args):
    if args.command == 'diff':
        args.diff = True
        args.dry_run = True
    else:
        args.diff = False

    if args.command == 'plan':
        args.dry_run = True
        args.command = 'apply'

    config_path = os.path.realpath(args.config_file)

    logger.init_logger(
        logger.StdErrLogger(
            log_level=args.log_level,
            use_colors=args.color == 'yes',
        ),
    )

    context.init_context(
        context.Context(
            config_path=config_path,
            dot_root=os.path.realpath(args.root),
            dry_run=args.dry_run,
        ),
    )

    cfg = config.create(tools.load_yaml_by_path(config_path))

    logger.logger().info(
        ['Preprocessed configuration'] + tools.safe_dump_yaml_lines(cfg.to_dict())
    )

    matcher = re.compile(args.field)
    all_plugins = plugin.registry().create(cfg).get_all_plugins_list()

    for name, plug in all_plugins:
        if not matcher.search(name):
            logger.logger().info(
                [
                    'Skipping plugin since it does not match field',
                    'plugin\t= %s',
                    'regex\t= %s',
                ], name, args.field,
            )
            continue

        with logger.logger().indent(label=name):
            plug.build()
            _apply_command(args, plug, args.command)


if __name__ == '__main__':
    main(_parse_args())
